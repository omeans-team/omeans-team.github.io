name: Smart Auto Create and Close Issues on Push

on:
  push:
    branches:
      - main
      - master

jobs:
  smart-manage-issues:
    runs-on: ubuntu-latest
    if: github.event_name == 'push'
    permissions:
      contents: read
      issues: write
      pull-requests: write
      actions: read
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
        
      - name: Smart Issue Management
        uses: actions/github-script@v7
        id: issue-management
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            // Fungsi untuk mendeteksi tipe perubahan
            function detectChangeType(files) {
              const patterns = {
                'frontend': /\.(js|jsx|ts|tsx|css|scss|html|vue|svelte)$/i,
                'backend': /\.(py|java|cpp|c|cs|php|rb|go|rs|swift|kt)$/i,
                'database': /\.(sql|db|sqlite|mdb)$/i,
                'config': /\.(json|yaml|yml|toml|ini|conf|config)$/i,
                'docs': /\.(md|txt|rst|adoc)$/i,
                'assets': /\.(png|jpg|jpeg|gif|svg|ico|mp4|mp3|pdf)$/i,
                'security': /(security|auth|password|token|key|secret|vulnerability|encrypt)/i,
                'performance': /(performance|optimization|cache|speed|fast|slow|memory|cpu)/i,
                'bugfix': /(fix|bug|error|issue|problem|crash|fail|broken|resolve)/i,
                'feature': /(feature|add|new|implement|create|introduce|enable)/i,
                'improve': /(improve|enhance|better|upgrade|update|modernize|polish)/i,
                'refactor': /(refactor|cleanup|restructure|reorganize|simplify|optimize)/i,
                'test': /(test|spec|unit|integration|e2e|cypress|jest|mocha)/i,
                'conflict': /(conflict|merge|resolve|rebase|merge-conflict)/i,
                'cherry-pick': /(cherry-pick|cherrypick|backport|port)/i,
                'hotfix': /(hotfix|urgent|critical|emergency|patch)/i,
                'breaking': /(breaking|major|incompatible|deprecate|remove)/i,
                'dependency': /(dependency|package|npm|yarn|pip|maven|gradle)/i,
                'ci-cd': /(ci|cd|pipeline|workflow|deploy|build|release)/i,
                'accessibility': /(accessibility|a11y|aria|screen-reader|wcag)/i,
                'mobile': /(mobile|responsive|touch|swipe|gesture)/i,
                'api': /(api|endpoint|rest|graphql|swagger|openapi)/i,
                'ui-ux': /(ui|ux|design|interface|user|experience|layout)/i,
                'data': /(data|analytics|metrics|logging|monitoring)/i,
                'devops': /(devops|infrastructure|docker|kubernetes|aws|azure)/i
              };
              
              const detectedTypes = new Set();
              
              files.forEach(file => {
                // Deteksi berdasarkan ekstensi file
                for (const [type, pattern] of Object.entries(patterns)) {
                  if (pattern.test(file.filename) || pattern.test(file.patch || '')) {
                    detectedTypes.add(type);
                  }
                }
              });
              
              // Deteksi berdasarkan commit message
              const commitMessage = context.payload.head_commit.message.toLowerCase();
              for (const [type, pattern] of Object.entries(patterns)) {
                if (pattern.test(commitMessage)) {
                  detectedTypes.add(type);
                }
              }
              
              return Array.from(detectedTypes);
            }
            
            // Fungsi untuk generate label berdasarkan tipe perubahan
            function generateLabels(changeTypes) {
              const labelMap = {
                'frontend': 'frontend',
                'backend': 'backend', 
                'database': 'database',
                'config': 'configuration',
                'docs': 'documentation',
                'assets': 'assets',
                'security': 'security',
                'performance': 'performance',
                'bugfix': 'bug',
                'feature': 'enhancement',
                'improve': 'improvement',
                'refactor': 'refactor',
                'test': 'testing',
                'conflict': 'merge-conflict',
                'cherry-pick': 'cherry-pick',
                'hotfix': 'hotfix',
                'breaking': 'breaking-change',
                'dependency': 'dependencies',
                'ci-cd': 'ci-cd',
                'accessibility': 'accessibility',
                'mobile': 'mobile',
                'api': 'api',
                'ui-ux': 'ui-ux',
                'data': 'data',
                'devops': 'devops'
              };
              
              const labels = ['auto-generated', 'update', 'push'];
              
              changeTypes.forEach(type => {
                if (labelMap[type]) {
                  labels.push(labelMap[type]);
                }
              });
              
              return labels;
            }
            
            // Fungsi untuk generate komentar berdasarkan topik
            function generateComment(changeTypes, commitMessage, changedFiles) {
              let comment = '## ðŸ“ Update Summary\n\n';
              
              // Analisis topik berdasarkan tipe perubahan
              const topics = [];
              if (changeTypes.includes('security')) topics.push('ðŸ”’ Security improvements');
              if (changeTypes.includes('performance')) topics.push('âš¡ Performance optimizations');
              if (changeTypes.includes('bugfix')) topics.push('ðŸ› Bug fixes');
              if (changeTypes.includes('feature')) topics.push('âœ¨ New features');
              if (changeTypes.includes('improve')) topics.push('ðŸš€ Improvements');
              if (changeTypes.includes('refactor')) topics.push('ðŸ”§ Code refactoring');
              if (changeTypes.includes('test')) topics.push('ðŸ§ª Testing improvements');
              if (changeTypes.includes('docs')) topics.push('ðŸ“š Documentation updates');
              if (changeTypes.includes('frontend')) topics.push('ðŸŽ¨ Frontend changes');
              if (changeTypes.includes('backend')) topics.push('âš™ï¸ Backend changes');
              if (changeTypes.includes('database')) topics.push('ðŸ—„ï¸ Database changes');
              if (changeTypes.includes('config')) topics.push('âš™ï¸ Configuration updates');
              if (changeTypes.includes('conflict')) topics.push('ðŸ”€ Merge conflict resolution');
              if (changeTypes.includes('cherry-pick')) topics.push('ðŸ’ Cherry-pick changes');
              if (changeTypes.includes('hotfix')) topics.push('ðŸš¨ Hotfix/urgent fix');
              if (changeTypes.includes('breaking')) topics.push('ðŸ’¥ Breaking changes');
              if (changeTypes.includes('dependency')) topics.push('ðŸ“¦ Dependency updates');
              if (changeTypes.includes('ci-cd')) topics.push('ðŸ”„ CI/CD pipeline changes');
              if (changeTypes.includes('accessibility')) topics.push('â™¿ Accessibility improvements');
              if (changeTypes.includes('mobile')) topics.push('ðŸ“± Mobile/responsive changes');
              if (changeTypes.includes('api')) topics.push('ðŸ”Œ API changes');
              if (changeTypes.includes('ui-ux')) topics.push('ðŸŽ¯ UI/UX improvements');
              if (changeTypes.includes('data')) topics.push('ðŸ“Š Data/analytics changes');
              if (changeTypes.includes('devops')) topics.push('ðŸ› ï¸ DevOps/infrastructure changes');
              
              if (topics.length > 0) {
                comment += '### ðŸŽ¯ Main Topics\n';
                topics.forEach(topic => {
                  comment += `- ${topic}\n`;
                });
                comment += '\n';
              }
              
              // Analisis file yang berubah
              const fileTypes = {};
              changedFiles.forEach(file => {
                const ext = file.filename.split('.').pop() || 'unknown';
                fileTypes[ext] = (fileTypes[ext] || 0) + 1;
              });
              
              if (Object.keys(fileTypes).length > 0) {
                comment += '### ðŸ“ File Type Analysis\n';
                Object.entries(fileTypes).forEach(([ext, count]) => {
                  comment += `- **${ext.toUpperCase()}**: ${count} file(s)\n`;
                });
                comment += '\n';
              }
              
              // Rekomendasi berdasarkan perubahan
              const recommendations = [];
              if (changeTypes.includes('security')) {
                recommendations.push('ðŸ” Consider security testing');
                recommendations.push('ðŸ“‹ Review access controls');
              }
              if (changeTypes.includes('performance')) {
                recommendations.push('ðŸ“Š Monitor performance metrics');
                recommendations.push('âš¡ Consider caching strategies');
              }
              if (changeTypes.includes('database')) {
                recommendations.push('ðŸ’¾ Backup database before deployment');
                recommendations.push('ðŸ” Test database migrations');
              }
              if (changeTypes.includes('frontend')) {
                recommendations.push('ðŸŽ¨ Test UI/UX changes');
                recommendations.push('ðŸ“± Verify responsive design');
              }
              if (changeTypes.includes('breaking')) {
                recommendations.push('âš ï¸ Review breaking changes impact');
                recommendations.push('ðŸ“‹ Update documentation');
              }
              if (changeTypes.includes('hotfix')) {
                recommendations.push('ðŸš¨ Test thoroughly before deployment');
                recommendations.push('ðŸ“ž Notify stakeholders');
              }
              if (changeTypes.includes('dependency')) {
                recommendations.push('ðŸ” Review dependency changes');
                recommendations.push('ðŸ§ª Test compatibility');
              }
              if (changeTypes.includes('ci-cd')) {
                recommendations.push('ðŸ”„ Test pipeline changes');
                recommendations.push('ðŸ“Š Monitor deployment success');
              }
              if (changeTypes.includes('accessibility')) {
                recommendations.push('â™¿ Test with screen readers');
                recommendations.push('ðŸŽ¯ Verify WCAG compliance');
              }
              if (changeTypes.includes('api')) {
                recommendations.push('ðŸ”Œ Test API endpoints');
                recommendations.push('ðŸ“‹ Update API documentation');
              }
              
              if (recommendations.length > 0) {
                comment += '### ðŸ’¡ Recommendations\n';
                recommendations.forEach(rec => {
                  comment += `- ${rec}\n`;
                });
                comment += '\n';
              }
              
              return comment;
            }
            
            // Mendapatkan informasi commit dan perubahan
            const { data: commits } = await github.rest.repos.compareCommits({
              owner: context.repo.owner,
              repo: context.repo.repo,
              base: context.payload.before,
              head: context.payload.after
            });
            
            const changedFiles = commits.files || [];
            const additions = changedFiles.reduce((sum, file) => sum + file.additions, 0);
            const deletions = changedFiles.reduce((sum, file) => sum + file.deletions, 0);
            
            // Deteksi tipe perubahan
            const changeTypes = detectChangeType(changedFiles);
            console.log('ðŸ” Detected change types:', changeTypes);
            
            // Generate labels
            const labels = generateLabels(changeTypes);
            console.log('ðŸ·ï¸ Generated labels:', labels);
            
            // Generate komentar
            const customComment = generateComment(changeTypes, context.payload.head_commit.message, changedFiles);
            
            // Tutup issue auto-generated yang sudah ada
            try {
              console.log('ðŸ” Looking for existing auto-generated issues to close...');
              const existingIssues = await github.rest.issues.listForRepo({
                owner: context.repo.owner,
                repo: context.repo.repo,
                state: 'open',
                labels: 'auto-generated'
              });
              
              if (existingIssues.data.length > 0) {
                console.log('ðŸ“ Found ' + existingIssues.data.length + ' existing auto-generated issues to close');
                
                for (const existingIssue of existingIssues.data) {
                  try {
                    const closeComment = '## âœ… Issue Auto Close Complete\n\n' +
                      'This issue has been automatically closed due to a new push to the `' + context.ref.replace('refs/heads/', '') + '` branch.\n\n' +
                      '**Status:** Auto Close Complete âœ…\n' +
                      '**Triggered by:** New push\n' +
                      '**Commit:** `' + context.payload.head_commit.id.substring(0, 7) + '`\n' +
                      '**Author:** ' + context.payload.head_commit.author.name + '\n' +
                      '**Date:** ' + new Date(context.payload.head_commit.timestamp).toLocaleString() + '\n\n' +
                      '**Reason:** New update has been pushed, making this issue outdated.\n\n' +
                      '**Change Types Detected:** ' + (changeTypes.join(', ') || 'General update') + '\n\n' +
                      '---\n' +
                      '*This comment was automatically added by GitHub Actions.*';
                    
                    await github.rest.issues.createComment({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      issue_number: existingIssue.number,
                      body: closeComment
                    });
                    
                    await github.rest.issues.update({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      issue_number: existingIssue.number,
                      state: 'closed'
                    });
                    
                    console.log('âœ… Closed existing issue #' + existingIssue.number);
                  } catch (closeError) {
                    console.error('âŒ Failed to close existing issue #' + existingIssue.number + ':', closeError.message);
                  }
                }
              } else {
                console.log('ðŸ“ No existing auto-generated issues found to close');
              }
            } catch (listError) {
              console.error('âŒ Failed to list existing issues:', listError.message);
              console.log('âš ï¸ Continuing with new issue creation...');
            }
            
            // Membuat issue baru
            const issueTitle = 'ðŸ”„ Update: ' + context.payload.head_commit.message.split('\n')[0];
            
            const issueBody = customComment +
              '**Commit:** `' + context.payload.head_commit.id.substring(0, 7) + '`\n' +
              '**Author:** ' + context.payload.head_commit.author.name + '\n' +
              '**Date:** ' + new Date(context.payload.head_commit.timestamp).toLocaleString() + '\n\n' +
              '### ðŸ“‹ Changes Made\n' +
              context.payload.head_commit.message + '\n\n' +
              '### ðŸ“ Files Modified\n' +
              '```\n' +
              changedFiles.map(f => f.filename).join('\n') + '\n' +
              '```\n\n' +
              '### ðŸ“Š Statistics\n' +
              '- **Additions:** +' + additions + ' lines\n' +
              '- **Deletions:** -' + deletions + ' lines\n' +
              '- **Total Changes:** ' + (additions + deletions) + ' lines\n' +
              '- **Files Changed:** ' + changedFiles.length + ' files\n\n' +
              '### ðŸ”— Related Links\n' +
              '- **Commit:** [' + context.payload.head_commit.id.substring(0, 7) + '](' + context.payload.head_commit.url + ')\n' +
              '- **Branch:** `' + context.ref.replace('refs/heads/', '') + '`\n' +
              '- **Repository:** [' + context.repo.owner + '/' + context.repo.repo + '](' + context.payload.repository.html_url + ')\n\n' +
              '---\n' +
              '*This issue was automatically created by GitHub Actions on push to ' + context.ref.replace('refs/heads/', '') + ' branch.*\n\n' +
              '## â±ï¸ Auto Complete Countdown\n\n' +
              '**Status:** ðŸ”„ Processing...\n' +
              '**Time Remaining:** 10 seconds\n' +
              '**Progress:** â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ 100%\n\n' +
              '> âš¡ This issue will automatically complete in **10 seconds**\n' +
              '> ðŸ“Š Change Types Detected: **' + (changeTypes.join(', ') || 'General update') + '**';

            try {
              // Get the GitHub username of the person who pushed
              const assignee = context.payload.sender.login;
              console.log('Push sender:', assignee);
              console.log('Sender email:', context.payload.sender.email);
              
              const issue = await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: issueTitle,
                body: issueBody,
                labels: labels,
                assignees: [assignee] // Auto-assign to the person who pushed
              });
              
              console.log('Issue created successfully: #' + issue.data.number);
              console.log('Auto-assigned to:', assignee);
              console.log('Labels applied:', labels);
              
              // Simpan issue number untuk step berikutnya
              core.setOutput('issue-number', issue.data.number);
              core.setOutput('issue-body', issueBody);
              core.setOutput('change-types', changeTypes.join(','));
              
              console.log('Issue number saved for auto-complete step:', issue.data.number);
              
            } catch (error) {
              console.error('âŒ Failed to create issue:', error.message);
              console.error('Error details:', JSON.stringify(error, null, 2));
              
              // Fallback: Create a simple comment instead
              try {
                console.log('Creating fallback comment...');
                const fallbackComment = 'ðŸš€ **Update Summary**\n\n' +
                  '**Commit:** `' + context.payload.head_commit.id.substring(0, 7) + '`\n' +
                  '**Author:** ' + context.payload.head_commit.author.name + '\n' +
                  '**Message:** ' + context.payload.head_commit.message + '\n' +
                  '**Change Types:** ' + (changeTypes.join(', ') || 'General update') + '\n\n' +
                  '*Issue creation failed, but update was processed successfully.*';
                
                console.log('Fallback comment created successfully');
                console.log('Issue creation failed, but fallback comment created');
              } catch (fallbackError) {
                console.error('Failed to create fallback comment:', fallbackError.message);
              }
            }
      
      - name: Auto Complete Issue
        if: always() && steps.issue-management.outputs.issue-number != '' && steps.issue-management.outputs.issue-number != 'null'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            console.log('Checking if auto-complete step should run...');
            console.log('Issue number output:', '${{ steps.issue-management.outputs.issue-number }}');
            console.log('Change types output:', '${{ steps.issue-management.outputs.change-types }}');
            
            const issueNumber = '${{ steps.issue-management.outputs.issue-number }}';
            const issueBody = '${{ steps.issue-management.outputs.issue-body }}';
            const changeTypes = '${{ steps.issue-management.outputs.change-types }}'.split(',');
            
            if (!issueNumber || issueNumber === '' || issueNumber === 'null') {
              console.log('No valid issue number found, skipping auto-complete');
              return;
            }
            
            console.log('Starting auto-complete process for issue #' + issueNumber);
            console.log('Original issue body length:', issueBody.length);
            console.log('Change types:', changeTypes);
            
            // Wait for 10 seconds
            console.log('Waiting 10 seconds before auto-completing...');
            await new Promise(resolve => setTimeout(resolve, 10000));
            
            try {
              console.log('Auto-completing issue #' + issueNumber + ' after 10 seconds...');
              
              // Update issue body dengan status complete
              const completeBody = issueBody.replace(
                '## Auto Complete Countdown\n\n' +
                '**Status:** Processing...\n' +
                '**Time Remaining:** 10 seconds\n' +
                '**Progress:** 100%\n\n' +
                '> This issue will automatically complete in **10 seconds**\n' +
                '> Change Types Detected: **' + (changeTypes.join(', ') || 'General update') + '**',
                '## Auto Complete Finished\n\n' +
                '**Status:** Complete\n' +
                '**Completion Time:** ' + new Date().toLocaleString() + '\n' +
                '**Progress:** 100% Complete\n\n' +
                '> This issue has been automatically completed!\n' +
                '> Change Types Detected: **' + (changeTypes.join(', ') || 'General update') + '**'
              );
              
              console.log('Updating issue body to complete status...');
              await github.rest.issues.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: parseInt(issueNumber),
                body: completeBody,
                state: 'closed'
              });
              
              console.log('Issue #' + issueNumber + ' status updated to closed');
              
              // Tambahkan komentar penutupan
              const completeComment = '## Issue Auto Complete\n\n' +
                'This issue has been automatically completed.\n\n' +
                '**Status:** Auto Complete\n' +
                '**Triggered by:** Push to `' + context.ref.replace('refs/heads/', '') + '` branch\n' +
                '**Commit:** `' + context.payload.head_commit.id.substring(0, 7) + '`\n' +
                '**Author:** ' + context.payload.head_commit.author.name + '\n' +
                '**Completion Time:** ' + new Date().toLocaleString() + '\n\n' +
                '**Change Types Detected:** ' + (changeTypes.join(', ') || 'General update') + '\n\n' +
                '**Reason:** Changes have been successfully processed and deployed.\n\n' +
                '---\n' +
                '*This comment was automatically added by GitHub Actions.*';
              
              console.log('Adding completion comment...');
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: parseInt(issueNumber),
                body: completeComment
              });
              
              console.log('Issue #' + issueNumber + ' auto-completed successfully');
              console.log('Auto-complete process finished for issue #' + issueNumber);
            } catch (error) {
              console.error('Failed to auto-complete issue #' + issueNumber + ':', error.message);
              console.error('Error details:', JSON.stringify(error, null, 2));
            }
