name: Smart Auto Create and Close Issues on Push

on:
  push:
    branches:
      - main
      - master
    paths-ignore:
      - '**.md'
      - '.github/**'
      - 'docs/**'

jobs:
  smart-manage-issues:
    runs-on: ubuntu-latest
    if: github.event_name == 'push'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
        
      - name: Smart Issue Management
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            // Fungsi untuk mendeteksi tipe perubahan
            function detectChangeType(files) {
              const patterns = {
                'frontend': /\.(js|jsx|ts|tsx|css|scss|html|vue|svelte)$/i,
                'backend': /\.(py|java|cpp|c|cs|php|rb|go|rs|swift|kt)$/i,
                'database': /\.(sql|db|sqlite|mdb)$/i,
                'config': /\.(json|yaml|yml|toml|ini|conf|config)$/i,
                'docs': /\.(md|txt|rst|adoc)$/i,
                'assets': /\.(png|jpg|jpeg|gif|svg|ico|mp4|mp3|pdf)$/i,
                'security': /(security|auth|password|token|key|secret|vulnerability|encrypt)/i,
                'performance': /(performance|optimization|cache|speed|fast|slow|memory|cpu)/i,
                'bugfix': /(fix|bug|error|issue|problem|crash|fail|broken|resolve)/i,
                'feature': /(feature|add|new|implement|create|introduce|enable)/i,
                'improve': /(improve|enhance|better|upgrade|update|modernize|polish)/i,
                'refactor': /(refactor|cleanup|restructure|reorganize|simplify|optimize)/i,
                'test': /(test|spec|unit|integration|e2e|cypress|jest|mocha)/i,
                'conflict': /(conflict|merge|resolve|rebase|merge-conflict)/i,
                'cherry-pick': /(cherry-pick|cherrypick|backport|port)/i,
                'hotfix': /(hotfix|urgent|critical|emergency|patch)/i,
                'breaking': /(breaking|major|incompatible|deprecate|remove)/i,
                'dependency': /(dependency|package|npm|yarn|pip|maven|gradle)/i,
                'ci-cd': /(ci|cd|pipeline|workflow|deploy|build|release)/i,
                'accessibility': /(accessibility|a11y|aria|screen-reader|wcag)/i,
                'mobile': /(mobile|responsive|touch|swipe|gesture)/i,
                'api': /(api|endpoint|rest|graphql|swagger|openapi)/i,
                'ui-ux': /(ui|ux|design|interface|user|experience|layout)/i,
                'data': /(data|analytics|metrics|logging|monitoring)/i,
                'devops': /(devops|infrastructure|docker|kubernetes|aws|azure)/i
              };
              
              const detectedTypes = new Set();
              
              files.forEach(file => {
                // Deteksi berdasarkan ekstensi file
                for (const [type, pattern] of Object.entries(patterns)) {
                  if (pattern.test(file.filename) || pattern.test(file.patch || '')) {
                    detectedTypes.add(type);
                  }
                }
              });
              
              // Deteksi berdasarkan commit message
              const commitMessage = context.payload.head_commit.message.toLowerCase();
              for (const [type, pattern] of Object.entries(patterns)) {
                if (pattern.test(commitMessage)) {
                  detectedTypes.add(type);
                }
              }
              
              return Array.from(detectedTypes);
            }
            
            // Fungsi untuk generate label berdasarkan tipe perubahan
            function generateLabels(changeTypes) {
              const labelMap = {
                'frontend': 'frontend',
                'backend': 'backend', 
                'database': 'database',
                'config': 'configuration',
                'docs': 'documentation',
                'assets': 'assets',
                'security': 'security',
                'performance': 'performance',
                'bugfix': 'bug',
                'feature': 'enhancement',
                'improve': 'improvement',
                'refactor': 'refactor',
                'test': 'testing',
                'conflict': 'merge-conflict',
                'cherry-pick': 'cherry-pick',
                'hotfix': 'hotfix',
                'breaking': 'breaking-change',
                'dependency': 'dependencies',
                'ci-cd': 'ci-cd',
                'accessibility': 'accessibility',
                'mobile': 'mobile',
                'api': 'api',
                'ui-ux': 'ui-ux',
                'data': 'data',
                'devops': 'devops'
              };
              
              const labels = ['auto-generated', 'update', 'push'];
              
              changeTypes.forEach(type => {
                if (labelMap[type]) {
                  labels.push(labelMap[type]);
                }
              });
              
              return labels;
            }
            
            // Fungsi untuk generate komentar berdasarkan topik
            function generateComment(changeTypes, commitMessage, changedFiles) {
              let comment = '## üìù Update Summary\n\n';
              
              // Analisis topik berdasarkan tipe perubahan
              const topics = [];
              if (changeTypes.includes('security')) topics.push('üîí Security improvements');
              if (changeTypes.includes('performance')) topics.push('‚ö° Performance optimizations');
              if (changeTypes.includes('bugfix')) topics.push('üêõ Bug fixes');
              if (changeTypes.includes('feature')) topics.push('‚ú® New features');
              if (changeTypes.includes('improve')) topics.push('üöÄ Improvements');
              if (changeTypes.includes('refactor')) topics.push('üîß Code refactoring');
              if (changeTypes.includes('test')) topics.push('üß™ Testing improvements');
              if (changeTypes.includes('docs')) topics.push('üìö Documentation updates');
              if (changeTypes.includes('frontend')) topics.push('üé® Frontend changes');
              if (changeTypes.includes('backend')) topics.push('‚öôÔ∏è Backend changes');
              if (changeTypes.includes('database')) topics.push('üóÑÔ∏è Database changes');
              if (changeTypes.includes('config')) topics.push('‚öôÔ∏è Configuration updates');
              if (changeTypes.includes('conflict')) topics.push('üîÄ Merge conflict resolution');
              if (changeTypes.includes('cherry-pick')) topics.push('üçí Cherry-pick changes');
              if (changeTypes.includes('hotfix')) topics.push('üö® Hotfix/urgent fix');
              if (changeTypes.includes('breaking')) topics.push('üí• Breaking changes');
              if (changeTypes.includes('dependency')) topics.push('üì¶ Dependency updates');
              if (changeTypes.includes('ci-cd')) topics.push('üîÑ CI/CD pipeline changes');
              if (changeTypes.includes('accessibility')) topics.push('‚ôø Accessibility improvements');
              if (changeTypes.includes('mobile')) topics.push('üì± Mobile/responsive changes');
              if (changeTypes.includes('api')) topics.push('üîå API changes');
              if (changeTypes.includes('ui-ux')) topics.push('üéØ UI/UX improvements');
              if (changeTypes.includes('data')) topics.push('üìä Data/analytics changes');
              if (changeTypes.includes('devops')) topics.push('üõ†Ô∏è DevOps/infrastructure changes');
              
              if (topics.length > 0) {
                comment += '### üéØ Main Topics\n';
                topics.forEach(topic => {
                  comment += `- ${topic}\n`;
                });
                comment += '\n';
              }
              
              // Analisis file yang berubah
              const fileTypes = {};
              changedFiles.forEach(file => {
                const ext = file.filename.split('.').pop() || 'unknown';
                fileTypes[ext] = (fileTypes[ext] || 0) + 1;
              });
              
              if (Object.keys(fileTypes).length > 0) {
                comment += '### üìÅ File Type Analysis\n';
                Object.entries(fileTypes).forEach(([ext, count]) => {
                  comment += `- **${ext.toUpperCase()}**: ${count} file(s)\n`;
                });
                comment += '\n';
              }
              
              // Rekomendasi berdasarkan perubahan
              const recommendations = [];
              if (changeTypes.includes('security')) {
                recommendations.push('üîç Consider security testing');
                recommendations.push('üìã Review access controls');
              }
              if (changeTypes.includes('performance')) {
                recommendations.push('üìä Monitor performance metrics');
                recommendations.push('‚ö° Consider caching strategies');
              }
              if (changeTypes.includes('database')) {
                recommendations.push('üíæ Backup database before deployment');
                recommendations.push('üîç Test database migrations');
              }
              if (changeTypes.includes('frontend')) {
                recommendations.push('üé® Test UI/UX changes');
                recommendations.push('üì± Verify responsive design');
              }
              if (changeTypes.includes('breaking')) {
                recommendations.push('‚ö†Ô∏è Review breaking changes impact');
                recommendations.push('üìã Update documentation');
              }
              if (changeTypes.includes('hotfix')) {
                recommendations.push('üö® Test thoroughly before deployment');
                recommendations.push('üìû Notify stakeholders');
              }
              if (changeTypes.includes('dependency')) {
                recommendations.push('üîç Review dependency changes');
                recommendations.push('üß™ Test compatibility');
              }
              if (changeTypes.includes('ci-cd')) {
                recommendations.push('üîÑ Test pipeline changes');
                recommendations.push('üìä Monitor deployment success');
              }
              if (changeTypes.includes('accessibility')) {
                recommendations.push('‚ôø Test with screen readers');
                recommendations.push('üéØ Verify WCAG compliance');
              }
              if (changeTypes.includes('api')) {
                recommendations.push('üîå Test API endpoints');
                recommendations.push('üìã Update API documentation');
              }
              
              if (recommendations.length > 0) {
                comment += '### üí° Recommendations\n';
                recommendations.forEach(rec => {
                  comment += `- ${rec}\n`;
                });
                comment += '\n';
              }
              
              return comment;
            }
            
            // Mendapatkan informasi commit dan perubahan
            const { data: commits } = await github.rest.repos.compareCommits({
              owner: context.repo.owner,
              repo: context.repo.repo,
              base: context.payload.before,
              head: context.payload.after
            });
            
            const changedFiles = commits.files || [];
            const additions = changedFiles.reduce((sum, file) => sum + file.additions, 0);
            const deletions = changedFiles.reduce((sum, file) => sum + file.deletions, 0);
            
            // Deteksi tipe perubahan
            const changeTypes = detectChangeType(changedFiles);
            console.log('üîç Detected change types:', changeTypes);
            
            // Generate labels
            const labels = generateLabels(changeTypes);
            console.log('üè∑Ô∏è Generated labels:', labels);
            
            // Generate komentar
            const customComment = generateComment(changeTypes, context.payload.head_commit.message, changedFiles);
            
            // Menutup issue auto-generated yang sudah ada
            const { data: existingIssues } = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              labels: 'auto-generated'
            });
            
            if (existingIssues.length > 0) {
              console.log(`üîç Found ${existingIssues.length} auto-generated issues to close`);
              
              for (const issue of existingIssues) {
                try {
                  // Menutup issue
                  await github.rest.issues.update({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issue.number,
                    state: 'closed'
                  });
                  
                  // Menambahkan komentar penutupan dengan status
                  const closeComment = '## ‚úÖ Issue Auto Close Complete\n\n' +
                    'This issue has been automatically closed due to a new push to the `' + context.ref.replace('refs/heads/', '') + '` branch.\n\n' +
                    '**Status:** Auto Close Complete ‚úÖ\n' +
                    '**Triggered by:** New push\n' +
                    '**Commit:** `' + context.payload.head_commit.id.substring(0, 7) + '`\n' +
                    '**Author:** ' + context.payload.head_commit.author.name + '\n' +
                    '**Date:** ' + new Date(context.payload.head_commit.timestamp).toLocaleString() + '\n\n' +
                    '**Reason:** New update has been pushed, making this issue outdated.\n\n' +
                    '**Change Types Detected:** ' + (changeTypes.join(', ') || 'General update') + '\n\n' +
                    '---\n' +
                    '*This comment was automatically added by GitHub Actions.*';
                  
                  await github.rest.issues.createComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issue.number,
                    body: closeComment
                  });
                  
                  console.log(`‚úÖ Closed issue #${issue.number}: ${issue.title}`);
                } catch (error) {
                  console.error(`‚ùå Failed to close issue #${issue.number}:`, error.message);
                }
              }
            } else {
              console.log('‚úÖ No auto-generated issues to close');
            }
            
            // Membuat issue baru
            const issueTitle = 'üîÑ Update: ' + context.payload.head_commit.message.split('\n')[0];
            
            const issueBody = customComment +
              '**Commit:** `' + context.payload.head_commit.id.substring(0, 7) + '`\n' +
              '**Author:** ' + context.payload.head_commit.author.name + '\n' +
              '**Date:** ' + new Date(context.payload.head_commit.timestamp).toLocaleString() + '\n\n' +
              '### üìã Changes Made\n' +
              context.payload.head_commit.message + '\n\n' +
              '### üìÅ Files Modified\n' +
              '```\n' +
              changedFiles.map(f => f.filename).join('\n') + '\n' +
              '```\n\n' +
              '### üìä Statistics\n' +
              '- **Additions:** +' + additions + ' lines\n' +
              '- **Deletions:** -' + deletions + ' lines\n' +
              '- **Total Changes:** ' + (additions + deletions) + ' lines\n' +
              '- **Files Changed:** ' + changedFiles.length + ' files\n\n' +
              '### üîó Related Links\n' +
              '- **Commit:** [' + context.payload.head_commit.id.substring(0, 7) + '](' + context.payload.head_commit.url + ')\n' +
              '- **Branch:** `' + context.ref.replace('refs/heads/', '') + '`\n' +
              '- **Repository:** [' + context.repo.owner + '/' + context.repo.repo + '](' + context.payload.repository.html_url + ')\n\n' +
              '---\n' +
              '*This issue was automatically created by GitHub Actions on push to ' + context.ref.replace('refs/heads/', '') + ' branch.*\n\n' +
              '## ‚è±Ô∏è Auto Complete Countdown\n\n' +
              '**Status:** üîÑ Processing...\n' +
              '**Time Remaining:** 10 seconds\n' +
              '**Progress:** ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà 100%\n\n' +
              '> ‚ö° This issue will automatically complete in **10 seconds**\n' +
              '> üìä Change Types Detected: **' + (changeTypes.join(', ') || 'General update') + '**';

            try {
              const issue = await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: issueTitle,
                body: issueBody,
                labels: labels,
                assignees: [context.payload.head_commit.author.name] // Auto assign berdasarkan user push
              });
              
              console.log('‚úÖ Issue created successfully: #' + issue.data.number);
              console.log('üë§ Auto-assigned to:', context.payload.head_commit.author.name);
              console.log('üè∑Ô∏è Labels applied:', labels);
              
              // Auto close issue setelah 10 detik untuk menandai sebagai complete
              setTimeout(async () => {
                try {
                  // Update issue body dengan status complete
                  const completeBody = issueBody.replace(
                    '## ‚è±Ô∏è Auto Complete Countdown\n\n' +
                    '**Status:** üîÑ Processing...\n' +
                    '**Time Remaining:** 10 seconds\n' +
                    '**Progress:** ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà 100%\n\n' +
                    '> ‚ö° This issue will automatically complete in **10 seconds**\n' +
                    '> üìä Change Types Detected: **' + (changeTypes.join(', ') || 'General update') + '**',
                    '## ‚úÖ Auto Complete Finished\n\n' +
                    '**Status:** ‚úÖ Complete\n' +
                    '**Completion Time:** ' + new Date().toLocaleString() + '\n' +
                    '**Progress:** ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà 100% ‚úÖ\n\n' +
                    '> üéâ This issue has been automatically completed!\n' +
                    '> üìä Change Types Detected: **' + (changeTypes.join(', ') || 'General update') + '**'
                  );
                  
                  await github.rest.issues.update({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issue.data.number,
                    body: completeBody,
                    state: 'closed'
                  });
                  
                  // Tambahkan komentar penutupan
                  const completeComment = '## ‚úÖ Issue Auto Complete\n\n' +
                    'This issue has been automatically completed.\n\n' +
                    '**Status:** Auto Complete ‚úÖ\n' +
                    '**Triggered by:** Push to `' + context.ref.replace('refs/heads/', '') + '` branch\n' +
                    '**Commit:** `' + context.payload.head_commit.id.substring(0, 7) + '`\n' +
                    '**Author:** ' + context.payload.head_commit.author.name + '\n' +
                    '**Completion Time:** ' + new Date().toLocaleString() + '\n\n' +
                    '**Change Types Detected:** ' + (changeTypes.join(', ') || 'General update') + '\n\n' +
                    '**Reason:** Changes have been successfully processed and deployed.\n\n' +
                    '---\n' +
                    '*This comment was automatically added by GitHub Actions.*';
                  
                  await github.rest.issues.createComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issue.data.number,
                    body: completeComment
                  });
                  
                  console.log('‚úÖ Issue #' + issue.data.number + ' auto-completed successfully');
                } catch (error) {
                  console.error('‚ùå Failed to auto-complete issue #' + issue.data.number + ':', error.message);
                }
              }, 10000); // 10 detik delay
              
            } catch (error) {
              console.error('‚ùå Failed to create issue:', error.message);
            }
